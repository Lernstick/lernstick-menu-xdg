#!/bin/sh

# gettext support
. gettext.sh
export TEXTDOMAIN=lernstick_backup

SCREENSHOT_DIRECTORY="/home/user/Screenshots"
LOG_FILE="/var/log/lernstick_backup"

# source config file
CONFIG_FILE="/etc/lernstickWelcome"
if [ -f ${CONFIG_FILE} ]
then
	. ${CONFIG_FILE}
else
	echo "${CONFIG_FILE} does not (yet) exist" | tee -a ${LOG_FILE}
	exit 0
fi

if [ "${Backup}" != "true" ]
then
	echo "continuous backup is not enabled" | tee -a ${LOG_FILE}
	exit 0
fi

show_error()
{
	TEXT="${1}"
	BLOCKING="${2}"

	if [ "$KDE_FULL_SESSION" ]
	then
		if [ "${BLOCKING}" = "true" ]
		then
			sudo -u user kdialog --error "${TEXT}"
		else
			sudo -u user kdialog --error "${TEXT}" &
		fi
	else
		# zenity's HTML interpreter is so dumb, it doesn't even understand <br>...
		# we need to replace it with "\\n"
		ZENITY_TEXT="$(echo ${TEXT} | sed 's/<br>/\\n/g')"
		echo "ZENITY_TEXT=\"${ZENITY_TEXT}\""
		if [ "${BLOCKING}" = "true" ]
		then
			sudo -u user zenity --error --text "${ZENITY_TEXT}"
		else
			sudo -u user zenity --error --text "${ZENITY_TEXT}" &
		fi
	fi

	# another variant with notify-send instead of a dialog
	# unfortunately, this doesn't work in Debian 8 GNOME
	# sudo -u user notify-send -i dialog-error "${ERROR_MESSAGE}"
}

get_existing_parent()
{
        DIRECTORY="${1}"
        while [ ! -d ${DIRECTORY} ]
        do
                DIRECTORY="$(dirname "${DIRECTORY}")"
        done
        echo "${DIRECTORY}"
}

do_rdiff()
{
	DESTINATION="${2}"
	echo "planned destination directory: ${DESTINATION}" | tee -a ${LOG_FILE}

	# Sometimes the destination directory doesn't exist yet.
	# In this case the call to df below would fail.
	# Therefore we have to search an existing (parent) directory for df.
	EXISTING_PARENT=$(get_existing_parent "${DESTINATION}")
	echo "existing destination parent directory: ${EXISTING_PARENT}" | tee -a ${LOG_FILE}
	# check if we need to run a file system check
	DEVICE="$(df "${EXISTING_PARENT}" | grep /dev/ | awk '{ print $1}')"
	if [ -n "${DEVICE}" ]
	then
		echo "backup destination device: ${DEVICE}" | tee -a ${LOG_FILE}
		if mount | grep ^"${DEVICE}" | grep "(ro," > /dev/null
		then
			show_error "$(eval_gettext "The file system on the backup device (<tt>\${DEVICE}</tt>) seems to be corrupt.<br>An interactive file system repair will be started...")" "true"
			#FS_TYPE="mount | grep ^/dev/sda2 | awk '{ print $5 }'"
			#echo "backup destination filesystem: ${FS_TYPE}" | tee -a ${LOG_FILE}
			FSCK_DONE_INFO="$(eval_gettext "File system check finished.\nYou can close this window now.")"
			xterm -T "$(eval_gettext "File System Repair")" -hold -e "fsck.vfat -v -r -w ${DEVICE}; echo -e \"${FSCK_DONE_INFO}\""
			mount -o remount,rw "${DEVICE}"
		fi
	fi

	# make sure that the backup destination directory exists
	# (rdiff-backup can auto-create the leaf destination directory but not
	# all parent directories)
	if [ ! -d "${DESTINATION}" ]
	then
		mkdir -p "${DESTINATION}"
	fi

	if rdiff-backup -v5 "${1}" "${DESTINATION}" >> ${LOG_FILE} 2>&1
	then
		delete_old_backups "${DESTINATION}"
	else
		# Sometimes rdiff-backup just stumbles over its own feet and
		# leaves a broken destination folder behind. Because
		# interactive repairing can take too long and is too difficult
		# for our users we have to use different fallback strategies.
		# Our first fallback strategy is to rename the old backup
		# folder and retry with a fresh one.
		echo "retrying after renaming broken destination folder" | tee -a ${LOG_FILE}
		rm -rf "${DESTINATION}.broken"
		mv "${DESTINATION}" "${DESTINATION}.broken"
		if rdiff-backup -v5 "${1}" "${DESTINATION}" >> ${LOG_FILE} 2>&1
		then
			delete_old_backups "${DESTINATION}"
		else
			ERROR_MESSAGE="$(eval_gettext "Backup to<br><tt>\${DESTINATION}</tt><br>failed!")"
			# It didn't work with a new folder, so maybe we run out of disk space?
			FREE_SPACE="$(df | grep ^${DEVICE} | awk '{ print $4}')"
			if [ "${FREE_SPACE}" = "0" ]
			then
				echo "there is no free diskspace left" | tee -a ${LOG_FILE}
				echo "retrying after removing all destination folders" | tee -a ${LOG_FILE}
				rm -rf "${DESTINATION}"
				rm -rf "${DESTINATION}.broken"
				if rdiff-backup -v5 "${1}" "${DESTINATION}" >> ${LOG_FILE} 2>&1
				then
					delete_old_backups "${DESTINATION}"
				else
					FREE_SPACE="$(df | grep ^${DEVICE} | awk '{ print $4}')"
					if [ "${FREE_SPACE}" = "0" ]
					then
						# show error message about full exchange partition
						show_error "${ERROR_MESSAGE}<br>$(eval_gettext "There is no free space left on device <tt>\${DEVICE}</tt>!")"
					else
						show_error "${ERROR_MESSAGE}"
					fi
				fi
			else
				show_error "${ERROR_MESSAGE}"
			fi
		fi
	fi
}

delete_old_backups()
{
	# When using a FAT32 partition as destination there is a problem:
	# With the long filenames rdiff-backup is using for its status files
	# in the rdiff-backup-data directory FAT32 can only save between
	# 11000 and 12000 files there.
	# After that all backup and repair runs just fail.
	# To prevent this disaster from happening again (yes, this happened at
	# a customer site) we limit the number of backups to keep.
	# There are at least 5 files per backup timestamp, so limiting the number
	# of backups to 500 seems to be a good default.
	MAX_COUNTER=500
	echo "trying to keep only ${MAX_COUNTER} backups..." | tee -a ${LOG_FILE}
	COUNTER=$(rdiff-backup -l --parsable-output "$1" | wc -l)
	echo "There are ${COUNTER} backups" | tee -a ${LOG_FILE}
	OVERHEAD=$((${COUNTER}-${MAX_COUNTER}))
	echo "overhead: ${OVERHEAD}" | tee -a ${LOG_FILE}
	if [ ${OVERHEAD} -gt 0 ]
	then
		echo "we should delete old backups" | tee -a ${LOG_FILE}
		TIMESTAMP=$(rdiff-backup -l --parsable-output $1 | sed -n $((${OVERHEAD}+1))p | awk '{ print $1 }')
		echo "last timestamp to keep: ${TIMESTAMP}" | tee -a ${LOG_FILE}
		rdiff-backup --force --remove-older-than ${TIMESTAMP} "$1"
	else
		echo "we don't need to delete old backups" | tee -a ${LOG_FILE}
	fi
}

do_backup()
{
	if [ "${BackupScreenshot}" = "true" ]
	then
		# make sure that the screenshots directory exists
		if [ ! -d "${SCREENSHOT_DIRECTORY}" ]
		then
			mkdir -p "${SCREENSHOT_DIRECTORY}"
			chmod 700 "${SCREENSHOT_DIRECTORY}"
		fi
		sudo -u user import -silent -window root - | convert - \
                  -filter Triangle \
                  -define filter:support=2 \
                  -unsharp 0.25x0.08+8.3+0.045 \
                  -dither None \
                  -posterize 136 \
                  -quality 62 \
                  -define jpeg:fancy-upsampling=off \
                  -define png:compression-filter=5 \
                  -define png:compression-level=9 \
                  -define png:compression-strategy=1 \
                  -define png:exclude-chunk=all \
                  -interlace none \
                  -colorspace sRGB \
                  /tmp/screenshot.jpg
                mv /tmp/screenshot.jpg "${SCREENSHOT_DIRECTORY}/screenshot $(date +"%Y-%m-%d %H.%M.%S").jpg"
	fi

	if [ "${BackupDirectoryEnabled}" = "true" ]
	then
		do_rdiff "${BackupSource}" "${BackupDirectory}"
	fi

	if [ "${BackupPartitionEnabled}" = "true" ]
	then
		BACKUP_DEVICE="$(blkid -l -o device -t LABEL="${BackupPartition}")"
		if [ ${BACKUP_DEVICE} ]
		then
			MOUNT_POINT="$(grep ${BACKUP_DEVICE} /proc/mounts | awk '{ print $2 }')"
			echo "mount point of ${BACKUP_DEVICE}: \"${MOUNT_POINT}\"" | tee -a ${LOG_FILE}
			if [ -z "${MOUNT_POINT}" ]
			then
				MOUNT_DIR="/backup/"
				MOUNT_POINT="${MOUNT_DIR}/${BackupPartition}"
				mkdir -p "${MOUNT_POINT}"
				chown root.root "${MOUNT_DIR}"
				chmod 700  "${MOUNT_DIR}"
				echo "calling \"mount ${BACKUP_DEVICE} ${MOUNT_POINT}\"" | tee -a ${LOG_FILE}
				mount ${BACKUP_DEVICE} "${MOUNT_POINT}"
			fi
			do_rdiff "${BackupSource}" "${MOUNT_POINT}/lernstick_backup"
		else
			show_error "$(eval_gettext "Backup partition<br><tt>\${BackupPartition}</tt><br>not found!")"
		fi
	fi
}

# add newline if logfile is not empty
if [ -f ${LOG_FILE} ]
then
	SIZE=$(wc -c < ${LOG_FILE})
	if [ "${SIZE}" != "0" ]
	then
		echo "" >> ${LOG_FILE}
	fi
fi

if [ "$1" = "once" ]
then
	echo "FINAL backup run at $(date -R)" | tee -a ${LOG_FILE}
	do_backup
else
	TIMEOUT=$(expr ${BackupFrequency} \* 60)
	while true; do
		echo "backup run at $(date -R)" | tee -a ${LOG_FILE}

		# get current time
		BEFORE="$(date +%s)"
		echo "system time in seconds before running backup: ${BEFORE}" | tee -a ${LOG_FILE}

		# execute command
		do_backup

		# wait until TIMEOUT is over
		AFTER="$(date +%s)"
		echo "system time in seconds after running backup: ${AFTER}" | tee -a ${LOG_FILE}
		# Now that we enabled ntp updates in the exam environment, the following
		# timeout calucation breaks when the system time changes while the backup is
		# running. Yes, we already run into this issue in the real world during a real exam...
		# Therefore we simply sleep for the configured timeout instead of trying to
		# stay close to the configured backup frequency.
		# SLEEP=$(expr ${TIMEOUT} - ${AFTER} + ${BEFORE})
		SLEEP=${TIMEOUT}
		if [ ${SLEEP} -gt 0 ]
		then
			echo "sleeping for ${SLEEP} seconds..." | tee -a ${LOG_FILE}
			sleep ${SLEEP}
		else
			echo "timeout already passed!" | tee -a ${LOG_FILE}
		fi
	done
fi
