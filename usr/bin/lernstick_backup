#!/bin/sh

# gettext support
. gettext.sh
export TEXTDOMAIN=lernstick_backup

SCREENSHOT_DIRECTORY="/home/user/Screenshots"
LOG_FILE="/var/log/lernstick_backup"

# source config file
CONFIG_FILE="/etc/lernstickWelcome"
if [ -f ${CONFIG_FILE} ]
then
	. ${CONFIG_FILE}
else
	echo "${CONFIG_FILE} does not (yet) exist" >> ${LOG_FILE}
	exit 0
fi

if [ "${Backup}" != "true" ]
then
	echo "continuous backup is not enabled" >> ${LOG_FILE}
	exit 0
fi

show_error()
{
	TEXT="${1}"

	if [ "$KDE_FULL_SESSION" ]
	then
		sudo -u user kdialog --error "${TEXT}" &
	else
		# zenity's HTML interpreter is so dumb, it doesn't even understand <br>...
		# we need to replace it with "\\n"
		ZENITY_TEXT="$(echo ${TEXT} | sed 's/<br>/\\n/g')"
		echo "ZENITY_TEXT=\"${ZENITY_TEXT}\""
		sudo -u user zenity --error --text "${ZENITY_TEXT}" &
	fi

	# another variant with notify-send instead of a dialog
	# unfortunately, this doesn't work in Debian 8 GNOME
	# sudo -u user notify-send -i dialog-error "${ERROR_MESSAGE}"
}

do_rdiff()
{
	# make sure that the backup destination directory exists
	DESTINATION="${2}"
	if [ ! -d "${DESTINATION}" ]
	then
		mkdir -p "${DESTINATION}"
	fi

	rdiff-backup -v5 "${1}" "${DESTINATION}" >> ${LOG_FILE} 2>&1
	RETURN_VALUE=$?
	echo "RETURN_VALUE=\"${RETURN_VALUE}\"" >> ${LOG_FILE}
	if [ ${RETURN_VALUE} -eq 0 ]
	then
		delete_old_backups "${DESTINATION}"
	else
		show_error "$(eval_gettext "Backup to<br><tt>\${DESTINATION}</tt><br>failed!")"
	fi
}

delete_old_backups()
{
	# When using a FAT32 partition as destination there is a problem:
	# With the long filenames rdiff-backup is using for its status files
	# in the rdiff-backup-data directory FAT32 can only save between
	# 11000 and 12000 files there.
	# After that all backup and repair runs just fail.
	# To prevent this disaster from happening again (yes, this happened at
	# a customer site) we limit the number of backups to keep.
	# There are at least 5 files per backup timestamp, so limiting the number
	# of backups to 500 seems to be a good default.
	MAX_COUNTER=500
	echo "trying to keep only ${MAX_COUNTER} backups..." >> ${LOG_FILE}
	COUNTER=$(rdiff-backup -l --parsable-output "$1" | wc -l)
	echo "There are ${COUNTER} backups" >> ${LOG_FILE}
	OVERHEAD=$((${COUNTER}-${MAX_COUNTER}))
	echo "overhead: ${OVERHEAD}" >> ${LOG_FILE}
	if [ ${OVERHEAD} -gt 0 ]
	then
		echo "we should delete old backups" >> ${LOG_FILE}
		TIMESTAMP=$(rdiff-backup -l --parsable-output $1 | sed -n $((${OVERHEAD}+1))p | awk '{ print $1 }')
		echo "last timestamp to keep: ${TIMESTAMP}" >> ${LOG_FILE}
		rdiff-backup --force --remove-older-than ${TIMESTAMP} "$1"
	else
		echo "we don't need to delete old backups" >> ${LOG_FILE}
	fi
}

do_backup()
{
	if [ "${BackupScreenshot}" = "true" ]
	then
		# make sure that the screenshots directory exists
		if [ ! -d "${SCREENSHOT_DIRECTORY}" ]
		then
			mkdir -p "${SCREENSHOT_DIRECTORY}"
			chmod 700 "${SCREENSHOT_DIRECTORY}"
		fi
		sudo -u user import -window root /tmp/screenshot.png
		mv /tmp/screenshot.png "${SCREENSHOT_DIRECTORY}/screenshot $(date +"%Y-%m-%d %H.%M.%S").png"
	fi

	if [ "${BackupDirectoryEnabled}" = "true" ]
	then
		do_rdiff "${BackupSource}" "${BackupDirectory}"
	fi

	if [ "${BackupPartitionEnabled}" = "true" ]
	then
		BACKUP_DEVICE="$(blkid -l -o device -t LABEL="${BackupPartition}")"
		if [ ${BACKUP_DEVICE} ]
		then
			MOUNT_POINT="$(grep ${BACKUP_DEVICE} /proc/mounts | awk '{ print $2 }')"
			echo "mount point of ${BACKUP_DEVICE}: \"${MOUNT_POINT}\"" >> ${LOG_FILE}
			if [ -z "${MOUNT_POINT}" ]
			then
				MOUNT_DIR="/mnt/backup/"
				MOUNT_POINT="${MOUNT_DIR}/${BackupPartition}"
				mkdir -p "${MOUNT_POINT}"
				chown root.root "${MOUNT_DIR}"
				chmod 700  "${MOUNT_DIR}"
				echo "calling \"mount ${BACKUP_DEVICE} ${MOUNT_POINT}\"" >> ${LOG_FILE}
				mount ${BACKUP_DEVICE} "${MOUNT_POINT}"
			fi
			do_rdiff "${BackupSource}" "${MOUNT_POINT}/lernstick_backup"
		else
			show_error "$(eval_gettext "Backup partition<br><tt>\${BackupPartition}</tt><br>not found!")"
		fi
	fi
}


SIZE=$(wc -c < ${LOG_FILE})
if [ "${SIZE}" != "0" ]
then
	echo "" >> ${LOG_FILE}
fi

if [ "$1" = "once" ]
then
	echo "FINAL backup run at $(date -R)" >> ${LOG_FILE}
	do_backup
else
	TIMEOUT=$(expr ${BackupFrequency} \* 60)
	while true; do
		echo "backup run at $(date -R)" >> ${LOG_FILE}

		# get current time
		BEFORE="$(date +%s)"
		echo "system time in seconds before running backup: ${BEFORE}" >> ${LOG_FILE}

		# execute command
		do_backup

		# wait until TIMEOUT is over
		AFTER="$(date +%s)"
		echo "system time in seconds after running backup: ${AFTER}" >> ${LOG_FILE}
		SLEEP=$(expr ${TIMEOUT} - ${AFTER} + ${BEFORE})
		if [ ${SLEEP} -gt 0 ]
		then
			echo "sleeping for ${SLEEP} seconds..." >> ${LOG_FILE}
			sleep ${SLEEP}
		else
			echo "timeout already passed!" >> ${LOG_FILE}
		fi
	done
fi
