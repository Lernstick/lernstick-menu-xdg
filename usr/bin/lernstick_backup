#!/bin/bash

# gettext support
. gettext.sh
export TEXTDOMAIN=lernstick_backup

LOG_FILE="/var/log/lernstick_backup"

# read config file
# (sourcing doesn't work when properties have whitespaces)
CONFIG_FILE="/etc/lernstickWelcome"
if [ -f ${CONFIG_FILE} ]
then
	declare -A CONFIG
	IFS="="
	while read -r key value
	do
		CONFIG[${key}]="${value}"
	done < ${CONFIG_FILE}
	unset IFS
else
	echo "${CONFIG_FILE} does not (yet) exist" | tee -a ${LOG_FILE}
	exit 0
fi

SCREENSHOT_DIRECTORY="${CONFIG[BackupSource]}/Screenshots"

if [ "${CONFIG[Backup]}" != "true" ]
then
	echo "continuous backup is not enabled" | tee -a ${LOG_FILE}
	exit 0
fi

show_error()
{
	TEXT="${1}"
	BLOCKING="${2}"

	if [ "$KDE_FULL_SESSION" ]
	then
		if [ "${BLOCKING}" = "true" ]
		then
			sudo -u user kdialog --error "${TEXT}"
		else
			sudo -u user kdialog --error "${TEXT}" &
		fi
	else
		# zenity's HTML interpreter is so dumb, it doesn't even understand <br>...
		# we need to replace it with "\\n"
		ZENITY_TEXT="$(echo ${TEXT} | sed 's/<br>/\\n/g')"
		echo "ZENITY_TEXT=\"${ZENITY_TEXT}\""
		if [ "${BLOCKING}" = "true" ]
		then
			sudo -u user zenity --error --text "${ZENITY_TEXT}"
		else
			sudo -u user zenity --error --text "${ZENITY_TEXT}" &
		fi
	fi

	# another variant with notify-send instead of a dialog
	# unfortunately, this doesn't work in Debian 8 GNOME
	# sudo -u user notify-send -i dialog-error "${ERROR_MESSAGE}"
}

get_existing_parent()
{
	DIRECTORY="${1}"
	while [ ! -d ${DIRECTORY} ]
	do
		DIRECTORY="$(dirname "${DIRECTORY}")"
	done
	echo "${DIRECTORY}"
}

reformat_backup_partition()
{
	if [ "${CONFIG[ExchangeAccess]}" = "true" ]
	then
		# If the exchange partition is user accessible it could be used for much more than
		# storing backups. Therefore formatting is not a valid fallback strategy in this case.
		echo "exchange partition is user accessible, formatting canceled." | tee -a ${LOG_FILE}
		return
	fi

	BACKUP_PARTITION=$(grep /exchange/partition /proc/mounts | awk '{ print $1 }')
	echo "backup partition: $BACKUP_PARTITION" | tee -a ${LOG_FILE}
	if umount $BACKUP_PARTITION
	then
		echo "unmounted backup partition before formatting" | tee -a ${LOG_FILE}
	else
		echo "ERROR: could not umount backup partition!" | tee -a ${LOG_FILE}
	fi
	LABEL="$(lsblk -no LABEL $BACKUP_PARTITION)"
	echo "label: $LABEL" | tee -a ${LOG_FILE}
	FSTYPE="$(lsblk -no FSTYPE $BACKUP_PARTITION)"
	echo "fstype: $FSTYPE" | tee -a ${LOG_FILE}
	case $FSTYPE in
		ntfs)
			mkfs.ntfs -f -L "$LABEL" $BACKUP_PARTITION
			;;
		vfat)
			mkfs.vfat -n "$LABEL" $BACKUP_PARTITION
			;;
		*)
			echo "unsupported file format!" | tee -a ${LOG_FILE}
			;;
	esac
	mount $BACKUP_PARTITION /exchange/partition
}

do_rdiff()
{
	DESTINATION="${2}"
	echo "planned destination directory: ${DESTINATION}" | tee -a ${LOG_FILE}

	# Sometimes the destination directory doesn't exist yet.
	# In this case the call to df below would fail.
	# Therefore we have to search an existing (parent) directory for df.
	EXISTING_PARENT=$(get_existing_parent "${DESTINATION}")
	echo "existing destination parent directory: ${EXISTING_PARENT}" | tee -a ${LOG_FILE}
	# check if we need to run a file system check
	DEVICE="$(df "${EXISTING_PARENT}" | grep /dev/ | awk '{ print $1}')"
	if [ -n "${DEVICE}" ]
	then
		echo "backup destination device: ${DEVICE}" | tee -a ${LOG_FILE}
		if mount | grep ^"${DEVICE}" | grep "(ro," > /dev/null
		then
			# The file system seems to be corrupted. Unfortunately, vfat is so fragile that this happens quite often
			# when students just unplug the USB stick before shutdown completes.
			# Interactive file system repairs (commented out below) turned out to be too irritating and complicated.
			# Therefore we better reformat the exchange partition...
			#
			# ------ old version with interactive file system repair ------
			# show_error "$(eval_gettext "The file system on the backup device (<tt>\${DEVICE}</tt>) seems to be corrupt.<br>An interactive file system repair will be started...")" "true"
			# FSCK_DONE_INFO="$(eval_gettext "File system check finished.\nYou can close this window now.")"
			# xterm -T "$(eval_gettext "File System Repair")" -hold -e "fsck.vfat -v -r -w ${DEVICE}; echo -e \"${FSCK_DONE_INFO}\""
			# mount -o remount,rw "${DEVICE}"
			#
			# ------ new version with reformatting ------
			reformat_backup_partition
		fi
	fi

	# make sure that the backup destination directory exists
	# (rdiff-backup can auto-create the leaf destination directory but not
	# all parent directories)
	if [ ! -d "${DESTINATION}" ]
	then
		mkdir -p "${DESTINATION}"
	fi

	if rdiff-backup -v5 "${1}" "${DESTINATION}" >> ${LOG_FILE} 2>&1
	then
		delete_old_backups "${DESTINATION}"
	else
		# Sometimes rdiff-backup just stumbles over its own feet and
		# leaves a broken destination folder behind. Because
		# interactive repairing can take too long and is too difficult
		# for our users we have to use different fallback strategies.
		# Our first fallback strategy is to rename the old backup
		# folder and retry with a fresh one.
		echo "retrying after renaming broken destination folder" | tee -a ${LOG_FILE}
		rm -rf "${DESTINATION}.old"
		mv "${DESTINATION}" "${DESTINATION}.old"
		if rdiff-backup -v5 "${1}" "${DESTINATION}" >> ${LOG_FILE} 2>&1
		then
			delete_old_backups "${DESTINATION}"
		else
			ERROR_MESSAGE="$(eval_gettext "Backup to<br><tt>\${DESTINATION}</tt><br>failed!")"
			# It didn't work with a new folder, so maybe we run out of disk space?
			FREE_SPACE="$(df | grep ^${DEVICE} | awk '{ print $4}')"
			if [ "${FREE_SPACE}" = "0" ]
			then
				echo "there is no free diskspace left" | tee -a ${LOG_FILE}
				echo "retrying after removing all destination folders" | tee -a ${LOG_FILE}
				rm -rf "${DESTINATION}"
				rm -rf "${DESTINATION}.old"
				if rdiff-backup -v5 "${1}" "${DESTINATION}" >> ${LOG_FILE} 2>&1
				then
					delete_old_backups "${DESTINATION}"
				else
					FREE_SPACE="$(df | grep ^${DEVICE} | awk '{ print $4}')"
					if [ "${FREE_SPACE}" = "0" ]
					then
						# when a broken filesystem is mounted the free space is sometimes also shown as 0%
						# therefore we also retry with reformatting here
						reformat_backup_partition
						if rdiff-backup -v5 "${1}" "${DESTINATION}" >> ${LOG_FILE} 2>&1
						then
							delete_old_backups "${DESTINATION}"
						else
							show_error "${ERROR_MESSAGE}"
						fi
					else
						show_error "${ERROR_MESSAGE}"
					fi
				fi
			else
				show_error "${ERROR_MESSAGE}"
			fi
		fi
	fi
}

delete_old_backups()
{
	# When using a FAT32 partition as destination there is a problem:
	# With the long filenames rdiff-backup is using for its status files
	# in the rdiff-backup-data directory FAT32 can only save between
	# 11000 and 12000 files there.
	# After that all backup and repair runs just fail.
	# To prevent this disaster from happening again (yes, this happened at
	# a customer site) we limit the number of backups to keep.
	# There are at least 5 files per backup timestamp, so limiting the number
	# of backups to 500 seems to be a good default.
	MAX_COUNTER=500
	echo "trying to keep only ${MAX_COUNTER} backups..." | tee -a ${LOG_FILE}
	COUNTER=$(rdiff-backup -l --parsable-output "$1" | wc -l)
	echo "There are ${COUNTER} backups" | tee -a ${LOG_FILE}
	OVERHEAD=$((${COUNTER}-${MAX_COUNTER}))
	echo "overhead: ${OVERHEAD}" | tee -a ${LOG_FILE}
	if [ ${OVERHEAD} -gt 0 ]
	then
		echo "we should delete old backups" | tee -a ${LOG_FILE}
		TIMESTAMP=$(rdiff-backup -l --parsable-output $1 | sed -n $((${OVERHEAD}+1))p | awk '{ print $1 }')
		echo "last timestamp to keep: ${TIMESTAMP}" | tee -a ${LOG_FILE}
		rdiff-backup --force --remove-older-than ${TIMESTAMP} "$1"
	else
		echo "we don't need to delete old backups" | tee -a ${LOG_FILE}
	fi
}

do_backup()
{
	# make sure that only one instance is running at the same time
	echo "trying to get lock..."
	LCK="/tmp/lernstick_backup.lck"
	exec 8>$LCK
	flock 8
	echo "lock aquired"

	if [ "${CONFIG[BackupScreenshot]}" = "true" ]
	then
		# make sure that the screenshots directory exists
		if [ ! -d "${SCREENSHOT_DIRECTORY}" ]
		then
			mkdir -p "${SCREENSHOT_DIRECTORY}"
			chmod 700 "${SCREENSHOT_DIRECTORY}"
		fi
		sudo -u user import -silent -window root - | convert - \
			-filter Triangle \
			-define filter:support=2 \
			-unsharp 0.25x0.08+8.3+0.045 \
			-dither None \
			-posterize 136 \
			-quality 62 \
			-define jpeg:fancy-upsampling=off \
			-define png:compression-filter=5 \
			-define png:compression-level=9 \
			-define png:compression-strategy=1 \
			-define png:exclude-chunk=all \
			-interlace none \
			-colorspace sRGB \
			/tmp/screenshot.jpg
		mv /tmp/screenshot.jpg "${SCREENSHOT_DIRECTORY}/screenshot $(date +"%Y-%m-%d %H.%M.%S").jpg"
	fi

	if [ "${CONFIG[BackupDirectoryEnabled]}" = "true" ]
	then
		do_rdiff "${CONFIG[BackupSource]}" "${CONFIG[BackupDirectory]}"
	fi

	if [ "${CONFIG[BackupPartitionEnabled]}" = "true" ]
	then
		BACKUP_DEVICE="$(blkid -l -o device -t LABEL="${CONFIG[BackupPartition]}")"
		if [ ${BACKUP_DEVICE} ]
		then
			MOUNT_POINT="$(grep ${BACKUP_DEVICE} /proc/mounts | awk '{ print $2 }')"
			echo "mount point of ${BACKUP_DEVICE}: \"${MOUNT_POINT}\"" | tee -a ${LOG_FILE}
			if [ -z "${MOUNT_POINT}" ]
			then
				MOUNT_DIR="/backup/"
				MOUNT_POINT="${MOUNT_DIR}/${CONFIG[BackupPartition]}"
				mkdir -p "${MOUNT_POINT}"
				chown root.root "${MOUNT_DIR}"
				chmod 700  "${MOUNT_DIR}"
				echo "calling \"mount ${BACKUP_DEVICE} ${MOUNT_POINT}\"" | tee -a ${LOG_FILE}
				mount ${BACKUP_DEVICE} "${MOUNT_POINT}"
			fi
			if [[ ${CONFIG[BackupDirectory]} == /exchange/partition/* ]]
			then
				echo "backup directory on mounted exchange partition" | tee -a ${LOG_FILE}
				PARTITION_BACKUP_DIR="${CONFIG[BackupDirectory]/#\/exchange\/partition\//}"
			else
				PARTITION_BACKUP_DIR="lernstick_backup"
			fi
			echo "PARTITION_BACKUP_DIR=\"$PARTITION_BACKUP_DIR\"" | tee -a ${LOG_FILE}
			do_rdiff "${CONFIG[BackupSource]}" "${MOUNT_POINT}/$PARTITION_BACKUP_DIR"
			echo "unmounting ${BACKUP_DEVICE} so that it can be temporarily removed" | tee -a ${LOG_FILE}
			umount ${BACKUP_DEVICE}
		else
			BP_TMP="${CONFIG[BackupPartition]}"
			show_error "$(eval_gettext "Backup partition<br><tt>\${BP_TMP}</tt><br>not found!")"
		fi
	fi

	flock -u 8
	echo "unlocked"
}

# add newline if logfile is not empty
if [ -f ${LOG_FILE} ]
then
	SIZE=$(wc -c < ${LOG_FILE})
	if [ "${SIZE}" != "0" ]
	then
		echo "" >> ${LOG_FILE}
	fi
fi

if [ "$1" = "once" ]
then
	echo "FINAL backup run at $(date -R)" | tee -a ${LOG_FILE}
	do_backup
else
	TIMEOUT=$(expr ${CONFIG[BackupFrequency]} \* 60)
	while true; do
		echo "backup run at $(date -R)" | tee -a ${LOG_FILE}

		# get current time
		BEFORE="$(date +%s)"
		echo "system time in seconds before running backup: ${BEFORE}" | tee -a ${LOG_FILE}

		# execute command
		do_backup

		# wait until TIMEOUT is over
		AFTER="$(date +%s)"
		echo "system time in seconds after running backup: ${AFTER}" | tee -a ${LOG_FILE}
		# Now that we enabled ntp updates in the exam environment, the following
		# timeout calucation breaks when the system time changes while the backup is
		# running. Yes, we already run into this issue in the real world during a real exam...
		# Therefore we simply sleep for the configured timeout instead of trying to
		# stay close to the configured backup frequency.
		# SLEEP=$(expr ${TIMEOUT} - ${AFTER} + ${BEFORE})
		SLEEP=${TIMEOUT}
		if [ ${SLEEP} -gt 0 ]
		then
			echo "sleeping for ${SLEEP} seconds..." | tee -a ${LOG_FILE}
			sleep ${SLEEP}
		else
			echo "timeout already passed!" | tee -a ${LOG_FILE}
		fi
	done
fi
